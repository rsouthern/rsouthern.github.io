<!doctype html><html lang=en-uk><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Wowchemy 4.8.0 for Hugo"><meta name=author content="Richard Southern"><meta name=description content="Automated orientation of the shading vector field using the intrinsic geometric properties of the object."><link rel=alternate hreflang=en-uk href=https://rsouthern.github.io/post/curv/><link rel=preconnect href=https://fonts.gstatic.com crossorigin><meta name=theme-color content="#2962ff"><script src=../../js/mathjax-config.js></script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css integrity="sha256-FMvZuGapsJLjouA6k7Eo2lusoAX9i0ShlWFG6qt7SLc=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/github.min.css crossorigin=anonymous title=hl-light><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/dracula.min.css crossorigin=anonymous title=hl-dark disabled><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.min.css integrity="sha512-1xoFisiGdy9nvho8EgXuXvnpR5GAMSjFwp40gSRE3NwdUdIMIKuPa7bqoUhLD0O/5tPNhteAsE5XyyMi5reQVA==" crossorigin=anonymous><script src=https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.2.2/lazysizes.min.js integrity="sha512-TmDwFLhg3UA4ZG0Eb4MIyT1O1Mb+Oww5kFG0uHqXsdbyZz9DcvYQhKpGgNkamAI6h2lGGZq2X8ftOJvF/XjTUg==" crossorigin=anonymous async></script><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js integrity crossorigin=anonymous async></script><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,400i%7CKarla:400,400i,700,700i%7CRoboto+Mono&display=swap"><link rel=stylesheet href=../../css/wowchemy.css><link rel=manifest href=../../index.webmanifest><link rel=icon type=image/png href=../../images/icon_hu0365f2187e15210a9118469a64220edc_142871_32x32_fill_lanczos_center_2.png><link rel=apple-touch-icon type=image/png href=../../images/icon_hu0365f2187e15210a9118469a64220edc_142871_192x192_fill_lanczos_center_2.png><link rel=canonical href=https://rsouthern.github.io/post/curv/><meta property="twitter:card" content="summary_large_image"><meta property="og:site_name" content="Richard's Blog"><meta property="og:url" content="https://rsouthern.github.io/post/curv/"><meta property="og:title" content="Principal Curvature Aligned Anisotropic Shading | Richard's Blog"><meta property="og:description" content="Automated orientation of the shading vector field using the intrinsic geometric properties of the object."><meta property="og:image" content="https://rsouthern.github.io/post/curv/featured.png"><meta property="twitter:image" content="https://rsouthern.github.io/post/curv/featured.png"><meta property="og:locale" content="en-uk"><meta property="article:published_time" content="2018-06-01T00:00:00+00:00"><meta property="article:modified_time" content="2018-06-01T00:00:00+00:00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://rsouthern.github.io/post/curv/"},"headline":"Principal Curvature Aligned Anisotropic Shading","image":["https://rsouthern.github.io/post/curv/featured.png"],"datePublished":"2018-06-01T00:00:00Z","dateModified":"2018-06-01T00:00:00Z","author":{"@type":"Person","name":"Richard Southern"},"publisher":{"@type":"Organization","name":"Richard's Blog","logo":{"@type":"ImageObject","url":"https://rsouthern.github.io/images/icon_hu0365f2187e15210a9118469a64220edc_142871_192x192_fill_lanczos_center_2.png"}},"description":"Automated orientation of the shading vector field using the intrinsic geometric properties of the object."}</script><title>Principal Curvature Aligned Anisotropic Shading | Richard's Blog</title></head><body id=top data-spy=scroll data-offset=70 data-target=#TableOfContents><script>window.wcDarkLightEnabled=true;</script><script>const isSiteThemeDark=false;</script><script src=../../js/load-theme.js></script><aside class=search-results id=search><div class=container><section class=search-header><div class="row no-gutters justify-content-between mb-3"><div class=col-6><h1>Search</h1></div><div class="col-6 col-search-close"><a class=js-search href=#><i class="fas fa-times-circle text-muted" aria-hidden=true></i></a></div></div><div id=search-box><input name=q id=search-query placeholder=Search... autocapitalize=off autocomplete=off autocorrect=off spellcheck=false type=search class=form-control></div></section><section class=section-search-results><div id=search-hits></div></section></div></aside><nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id=navbar-main><div class=container><div class="d-none d-lg-inline-flex"><a class=navbar-brand href=../../>Richard's Blog</a></div><button type=button class=navbar-toggler data-toggle=collapse data-target=#navbar-content aria-controls=navbar aria-expanded=false aria-label="Toggle navigation">
<span><i class="fas fa-bars"></i></span></button><div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none"><a class=navbar-brand href=../../>Richard's Blog</a></div><div class="navbar-collapse main-menu-item collapse justify-content-start" id=navbar-content><ul class="navbar-nav d-md-inline-flex"><li class=nav-item><a class=nav-link href=../../#about><span>Home</span></a></li><li class=nav-item><a class=nav-link href=../../#publications><span>Publications</span></a></li><li class=nav-item><a class=nav-link href=../../#posts><span>Posts</span></a></li><li class=nav-item><a class=nav-link href=../../#talks><span>Talks</span></a></li></ul></div><ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2"><li class=nav-item><a class="nav-link js-search" href=# aria-label=Search><i class="fas fa-search" aria-hidden=true></i></a></li><li class="nav-item dropdown theme-dropdown"><a href=# class=nav-link data-toggle=dropdown aria-haspopup=true><i class="fas fa-moon" aria-hidden=true></i></a><div class=dropdown-menu><a href=# class="dropdown-item js-set-theme-light"><span>Light</span></a>
<a href=# class="dropdown-item js-set-theme-dark"><span>Dark</span></a>
<a href=# class="dropdown-item js-set-theme-auto"><span>Automatic</span></a></div></li></ul></div></nav><article class=article><div class="article-container pt-3"><h1>Principal Curvature Aligned Anisotropic Shading</h1><div class=article-metadata><span class=article-date>Jun 1, 2018</span>
<span class=middot-divider></span><span class=article-reading-time>8 min read</span></div></div><div class="article-header container-fluid featured-image-wrapper mt-4 mb-4" style=max-width:300px;max-height:300px><div style=position:relative><img src=../../post/curv/featured.png alt class=featured-image></div></div><div class=article-container><div class=article-style><p>In this post I will discuss the math and code behind a method to generate the automated orientation of a shading vector field using the intrinsic geometric properties of the object.</p><h3 id=background>Background</h3><p>Anisotropic reflectance models are handy for modeling shading behaviours at the microfacet level which conform with some sort of oriented field, for example, brushed metal:
<img src=Brushed_Aluminium.jpg alt="Brushed aluminum"></p><p>The <a href=http://radsite.lbl.gov/radiance/papers/sg92/paper.html>Ward anisotropic specular reflectance model</a> can (after some simplification, for which I unfortunately do not have a clear reference) be stated as:
\begin{equation}
\frac{(\mathbf{l}\cdot \mathbf{n})}{(\mathbf{v}\cdot \mathbf{n})} \exp \left( -2 \frac{ \left(\frac{\mathbf{h}\cdot\mathbf{x}}{\alpha_x} \right)^2 + \left(\frac{\mathbf{h}\cdot \mathbf{y}}{\alpha_y} \right)^2}{(1+\mathbf{h} \cdot \mathbf{n})}\right),
\end{equation}
where \(\mathbf{n}\) is the surface normal at a point, $\mathbf{l}$ is the vector from the point to the light source, \(\mathbf{v}\) is the vector from the point to the eye and \(\mathbf{h}\) is the half vector defined as \(\mathbf{h}=(\mathbf{l}+\mathbf{v})/\|\cdot \| \). The important anisotropic bits are the vectors \(\mathbf{x}, \mathbf{y}\), which define the (orthogonal) directions of anisotropy, and \(\alpha_x\) and \(\alpha_y\) define the standard deviation of the surface slope in the \(\mathbf{x}\) and \(\mathbf{y}\) directions respectively. They scale the &ldquo;amount&rdquo; of anisotropy in each of the directions. Note that \(\mathbf{x}\), \(\mathbf{y}\), and \(\mathbf{n}\), should define an orthogonal coordinate frame.</p><p>This might be implemented in a fragment shader as something similar to this:</p><pre><code class=language-cpp>   vec3 halfwayVector = normalize(lightDirection + viewDirection);
   vec3 normalDirection = normalize(FragNormal);
   vec3 tangentDirection = normalize(FragK1);
   vec3 binormalDirection = normalize(FragK2); // this also works: cross(normalDirection, tangentDirection);
   float dotLN = dot(lightDirection, normalDirection);
   vec3 diffuseReflection = attenuation * Light.Ld * Material.Kd * max(0.0, dotLN);
   float dotHN = dot(halfwayVector, normalDirection);
   float dotVN = dot(viewDirection, normalDirection);
   float dotHTAlphaX = dot(halfwayVector, tangentDirection) / alphaX;
   float dotHBAlphaY = dot(halfwayVector, binormalDirection) / alphaY;

   vec3 specularReflection;
   if (dotLN &lt; 0.0) // light source on the wrong side?
   {specularReflection = vec3(0.0);} else {
      // light source on the right side
      specularReflection = attenuation * Material.Ks
         * max(0.0,(dotLN/dotVN))
         * exp(-2.0 * (dotHTAlphaX * dotHTAlphaX + dotHBAlphaY * dotHBAlphaY) / (1.0 + dotHN));
   }
   fragColor = vec4(specularReflection + diffuseReflection, 1.0);
</code></pre><p>In order for us to generate good quality anisotropic fields using this formulation we see that we would have to provide per-pixel values for \(\mathbf{x}\), \(\mathbf{y}\), \(\alpha_x\) and \(\alpha_y\) (note that as \(\mathbf{y}\) is orthogonal to \(\mathbf{x}\) and \(\mathbf{n}\) so theoretically this can be deduced). Typically in a shader the vector field would be inferred by interpolation from a texture map containing direction vectors. As this involves a lot of effort, I looked into something a little more automated.</p><h3 id=lines-of-principal-curvature>Lines of Principal Curvature</h3><p>Most interesting surfaces are curved in some way. You&rsquo;re probably already familiar with the concept of a <em>normal</em> to a surface: if we zoom in enough to a surface (or manifold) it will look pretty flat. The vector defining the orientation of this plane is called a normal at a point on the surface.</p><p>Interestingly there are two other vectors that are defined in that tangent plane - one defines the direction and magnitude in which the rate the normal changes across the surface is at a <em>maximum</em>, and other the <em>least</em> - these are called the maximum and minimum principal curvature directions respectively, and are often symbolized by \(\mathbf{k}_1\) and \(\mathbf{k}_2\) respectively.</p><center><img width=50% src=https://upload.wikimedia.org/wikipedia/commons/e/eb/Minimal_surface_curvature_planes-en.svg></center>
The <a href=https://en.wikipedia.org/wiki/Principal_curvature>figure</a> above demonstrates the principal curvature directions for a saddle point, which lie in the orthogonal bisecting planes which intersect at the point where the curvature is measured. Interestingly a geometrically perfect saddle point and sphere would have $ \\|\mathbf{k}_1\\| = \\|\mathbf{k}_2\\| $.<p>These vectors are defined at all points over a smooth surface, and seem like a good choice for an intrinsic surface property suitable for defining our shading orientation, i.e. let \(\mathbf{k}_1 = \alpha_x \mathbf{x}\) and \(\mathbf{k}_2 = \alpha_y \mathbf{y}\). However there is a snag - the flow of the principal curvature direction is undefined, e.g. \(\mathbf{k}_1, \mathbf{k}_2\) and \(-\mathbf{k}_1, -\mathbf{k}_2\) are both equally valid principle curvature directions at any point as the frame can be arbitrarily flipped around (which we&rsquo;ll see later is a bit of a problem).</p><h3 id=computing-the-principal-curvature-directions>Computing the Principal Curvature Directions</h3><p>There are a number of methods to compute principal curvature directions over a triangle mesh. I&rsquo;m not going to dwell on it here. The library I used for this is <a href=https://github.com/libigl/libigl>libigl</a> which provides a simple header only library based on the math library <a href=http://eigen.tuxfamily.org>Eigen</a>. The full explanation of how libigl deduces the principle curvature directions is described <a href=http://libigl.github.io/libigl/tutorial/tutorial.html#curvaturedirections>here</a>.</p><p>The code for loading up a mesh, deducing vertex normals and extracting the principal curvature directions is below:</p><pre><code class=language-cpp>    // Read a mesh from a file into igl
    MatrixXfr V;
    MatrixXir F;
    igl::read_triangle_mesh(filename, V, F);

    // Determine the smooth corner normals
    MatrixXfr N;
    igl::per_vertex_normals(V,F,N);

    // Compute the principle curvature directions and magnitude using quadric fitting
    MatrixXfr K1,K2;
    Eigen::VectorXf KV1,KV2;
    igl::principal_curvature(V,F,K1,K2,KV1,KV2);
</code></pre><p>Note that the KV1 and KV2 hold the magnitude of each vector (K1 and K2 are normalized). This seemed a bit wasteful so I recombined these into a single vertex structure which contained the position, normal and scaled \(\mathbf{k}_1\) and \(\mathbf{k}_2\):</p><pre><code class=language-cpp>    MatrixXfr KV1_mat(K1.rows(), K1.cols()); KV1_mat &lt;&lt; KV1,KV1,KV1;
    MatrixXfr KV2_mat(K2.rows(), K2.cols()); KV2_mat &lt;&lt; KV2,KV2,KV2;
    K1.array() = KV1_mat.array() * K1.array();
    K2.array() = KV2_mat.array() * K2.array();

    // Now concatenate our per vertex data into a big chunk of data in Eigen
    MatrixXfr Vertices(V.rows(), V.cols() + N.cols() + K1.cols() + K2.cols());
    Vertices &lt;&lt; V, N, K1, K2;
</code></pre><p>Be wary as what these libraries gain in ease of use they sacrifice in terms of performance, so the application takes quite a while on startup to compute these matrices and vectors.</p><p>The curvature vectors generated using this process can be visualised as follows:
<img src=curvatureshading_wrong_vectors.png alt="Unoriented curvature vectors">
In this case the coordinate frame at each point is defined by the normal (in red), \(\mathbf{k}_1\), the maximum curvature direction and magnitude (in blue) and \(\mathbf{k}_2\), the minimum curvature direction (in green).</p><h3 id=early-results>Early results</h3><p>This all sounds like a great idea, but when we render these vectors, we get something a bit unexpected:
<img src=curvatureshading_wrong.png alt="Unoriented curvature shading">
Actually, these results are entirely predictable. For a first implementation, the curvatures are defined as vertex properties, which are simply passed on to the fragment shader to shade. This means that the curvatures are being <em>intepolated across the face per fragment</em>.</p><p>Looking at the curvature directions from the previous section, we can see that the curvature vectors do not define a consistent flow over the surface. This is because the curvature is deduced independently at each vertex, and perfectly valid in either direction of flow, e.g. I could rotate by 180 degrees about the normal and the principle curvature directions are the same.</p><p>To the Ward shading algorithm it doesn&rsquo;t matter, as \(\mathbf{x}\) and \(\mathbf{y}\) are effectively squared so the sign will disappear. However, during rasterization the vectors will be interpolated across the face - the curvature vectors at the corners of a face may be pointing in opposite directions, which means that the interpolated vector will sweep between them.</p><p>One option is to re-orient all of the curvature vectors as a preprocess. The only method I&rsquo;m aware of to consistently orient the curvature field is based on the method described in <a href="https://dl.acm.org/citation.cfm?id=882296">Anisotropic Polygonal Remeshing</a> by Alliez et al. (also available <a href=ftp://ftp-sop.inria.fr/prisme/alliez/anisotropic.pdf>[here]</a>) but this involves smoothing the tensor field, identifying umbilics and iteratively growing streamlines across the surface, which seemed somewhat tedious.</p><h3 id=curvature-direction-correction-on-the-gpu>Curvature Direction Correction on the GPU</h3><p>One of the convenient properties of the rendering process is that the triangle mesh (which may have shared vertex properties) is essentially broken up into independent triangles for the purposes of rendering as fragments. This effectively means that the vertex properties will be duplicated for each corner of each face coincident on a vertex.</p><p>Each face with the vertex properties to be interpolated are passed on to a Geometry Shader before the Fragment Shading stage of the pipeline. At this stage we are free to flip around \(\mathbf{k}_1\) and \(\mathbf{k}_2\) in order to ensure that all the curvature vectors at the corners are consistently oriented for this particular face. Note that which a neighbouring face might have these vectors oriented in a different direction, it doesn&rsquo;t matter due to the properties of the Ward shading model.</p><pre><code class=language-cpp>void main() {
    // The first triangle vertex is just going to be copied across
    gl_Position = gl_in[0].gl_Position;
    FragPosition = GeoPosition[0];
    FragNormal = GeoNormal[0];
    FragK1 = GeoK1[0];
    FragK2 = GeoK2[0];
    EmitVertex();

    for(int i = 1; i &lt; 3;  ++i) {
        // Copy across the vertex position
        gl_Position = gl_in[i].gl_Position;
        FragPosition = GeoPosition[i];
        FragNormal = GeoNormal[i];

        // Determine whether the curvature is flipped, if so, correct the curvature normal
        FragK1 = ((dot(GeoK1[0], GeoK1[i]) &lt; 0.0)?-1.0:1.0) * GeoK1[i];
        FragK2 = ((dot(GeoK2[0], GeoK2[i]) &lt; 0.0)?-1.0:1.0) * GeoK2[i];        

        // Emit the vertex of this primitive
        EmitVertex();
    }

    // Finish the triangle (strip)
    EndPrimitive();
}
</code></pre><p>As you can see all this does is copy across the first vertex, and then copy across the other two triangle vertices, but first possibly flipping the curvature vectors if they are oriented differently to the first vertex. Not particularly high-brow stuff, but it gets the job done.</p><h3 id=final-results>Final Results</h3><p>Here is the bust model with three different scalings of the anisotropy aligned to the principle curvature directions:</p><table width=100%><tr><td><img width=100% src=bust01.png></td><td><img width=100% src=bust02.png></td><td><img width=100% src=bust03.png></td></tr></table><p>While the face flipping problem has been fixed, the obvious issue with these results in that the curvature is not particularly smooth, mainly because of the resolution of the model but also because there has been not smoothing of the vector field. There are also issues relating to the placement of umbilics. These things could be improved by performing smoothing as described in <a href="https://dl.acm.org/citation.cfm?id=882296">this method</a> or using a mesh with a higher resolution. In addition, a method which allows the user to &ldquo;hide&rdquo; umbilic points in geometric areas where they won&rsquo;t be seen would be useful.</p><h3 id=downloads>Downloads</h3><p>The source code is hosted on <a href=https://github.com/rsouthern/Examples>GitHub</a>. Clone it from the repository using the following command from your console:</p><pre><code class=language-shell>git clone https://github.com/rsouthern/Examples
</code></pre><p>This example is under rendering/curv.</p></div><div class=article-tags><a class="badge badge-light" href=../../tag/glsl/>glsl</a>
<a class="badge badge-light" href=../../tag/opengl/>opengl</a>
<a class="badge badge-light" href=../../tag/rendering/>rendering</a></div><div class=share-box aria-hidden=true><ul class=share><li><a href="https://twitter.com/intent/tweet?url=https://rsouthern.github.io/post/curv/&text=Principal%20Curvature%20Aligned%20Anisotropic%20Shading" target=_blank rel=noopener class=share-btn-twitter><i class="fab fa-twitter"></i></a></li><li><a href="https://www.facebook.com/sharer.php?u=https://rsouthern.github.io/post/curv/&t=Principal%20Curvature%20Aligned%20Anisotropic%20Shading" target=_blank rel=noopener class=share-btn-facebook><i class="fab fa-facebook"></i></a></li><li><a href="mailto:?subject=Principal%20Curvature%20Aligned%20Anisotropic%20Shading&body=https://rsouthern.github.io/post/curv/" target=_blank rel=noopener class=share-btn-email><i class="fas fa-envelope"></i></a></li><li><a href="https://www.linkedin.com/shareArticle?url=https://rsouthern.github.io/post/curv/&title=Principal%20Curvature%20Aligned%20Anisotropic%20Shading" target=_blank rel=noopener class=share-btn-linkedin><i class="fab fa-linkedin-in"></i></a></li><li><a href="whatsapp://send?text=Principal%20Curvature%20Aligned%20Anisotropic%20Shading%20https://rsouthern.github.io/post/curv/" target=_blank rel=noopener class=share-btn-whatsapp><i class="fab fa-whatsapp"></i></a></li><li><a href="https://service.weibo.com/share/share.php?url=https://rsouthern.github.io/post/curv/&title=Principal%20Curvature%20Aligned%20Anisotropic%20Shading" target=_blank rel=noopener class=share-btn-weibo><i class="fab fa-weibo"></i></a></li></ul></div><div class="media author-card content-widget-hr"><a href=https://rsouthern.github.io/><img class="avatar mr-3 avatar-circle" src=../../author/richard-southern/avatar_hu8b4b6ae9a405f1b6aee3b6ae457da189_173063_270x270_fill_q90_lanczos_center.jpg alt="Richard Southern"></a><div class=media-body><h5 class=card-title><a href=https://rsouthern.github.io/>Richard Southern</a></h5><h6 class=card-subtitle>Lead Developer</h6><p class=card-text>Leader, Graphics Researcher, Software Engineer</p><ul class=network-icon aria-hidden=true><li><a href=https://github.com/rsouthern target=_blank rel=noopener><i class="fab fa-github"></i></a></li><li><a href=https://www.linkedin.com/in/richard-southern-70289b12/ target=_blank rel=noopener><i class="fab fa-linkedin"></i></a></li><li><a href=../../Downloads/cv.pdf><i class="ai ai-cv"></i></a></li></ul></div></div><div class="article-widget content-widget-hr"><h3>Related</h3><ul><li><a href=../../post/fins/>Realtime Silhouette Rendering with Consistent Geometric Fins</a></li><li><a href=../../post/noisetexture/>A Templated Implementation of Noise Texture</a></li><li><a href=../../publication/geomorph/>Creation and control of real-time continuous level of detail on programmable graphics hardware</a></li></ul></div></div></article><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/instant.page/5.1.0/instantpage.min.js integrity="sha512-1+qUtKoh9XZW7j+6LhRMAyOrgSQKenQ4mluTR+cvxXjP1Z54RxZuzstR/H9kgPXQsVB8IW7DMDFUJpzLjvhGSQ==" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/highlight.min.js integrity="sha512-TDKKr+IvoqZnPzc3l35hdjpHD0m+b2EC2SrLEgKDRWpxf2rFCxemkgvJ5kfU48ip+Y+m2XVKyOCD85ybtlZDmw==" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/r.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/c++.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.min.js integrity="sha512-SeiQaaDh73yrb56sTW/RgVdi/mMqNeM2oBwubFHagc5BkixSpP1fvqF47mKzPGWYSSy4RwbBunrJBQ4Co8fRWA==" crossorigin=anonymous></script><script>const code_highlighting=true;</script><script>const search_config={"indexURI":"/index.json","minLength":1,"threshold":0.3};const i18n={"no_results":"No results found","placeholder":"Search...","results":"results found"};const content_type={'post':"Posts",'project':"Projects",'publication':"Publications",'talk':"Talks",'slides':"Slides"};</script><script id=search-hit-fuse-template type=text/x-template>
      <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
      </div>
    </script><script src=https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin=anonymous></script><script src=../../js/wowchemy.min.4c2bca31150ce93c5a5e43b8a50f22fd.js></script><div class=container><footer class=site-footer><p class=powered-by></p><p class=powered-by>Published with
<a href=https://wowchemy.com target=_blank rel=noopener>Wowchemy</a> —
the free, <a href=https://github.com/wowchemy/wowchemy-hugo-modules target=_blank rel=noopener>open source</a> website builder that empowers creators.
<span class=float-right aria-hidden=true><a href=# class=back-to-top><span class=button_icon><i class="fas fa-chevron-up fa-2x"></i></span></a></span></p></footer></div><div id=modal class="modal fade" role=dialog><div class=modal-dialog><div class=modal-content><div class=modal-header><h5 class=modal-title>Cite</h5><button type=button class=close data-dismiss=modal aria-label=Close>
<span aria-hidden=true>&#215;</span></button></div><div class=modal-body><pre><code class="tex hljs"></code></pre></div><div class=modal-footer><a class="btn btn-outline-primary my-1 js-copy-cite" href=# target=_blank><i class="fas fa-copy"></i>Copy</a>
<a class="btn btn-outline-primary my-1 js-download-cite" href=# target=_blank><i class="fas fa-download"></i>Download</a><div id=modal-error></div></div></div></div></div></body></html>