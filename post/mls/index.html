<!doctype html><html lang=en-uk><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Wowchemy 4.8.0 for Hugo"><meta name=author content="Richard Southern"><meta name=description content="An implementation of N-Dimensional Moving Least Squares on point clouds in C++."><link rel=alternate hreflang=en-uk href=https://rsouthern.github.io/post/mls/><link rel=preconnect href=https://fonts.gstatic.com crossorigin><meta name=theme-color content="#2962ff"><script src=../../js/mathjax-config.js></script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css integrity="sha256-FMvZuGapsJLjouA6k7Eo2lusoAX9i0ShlWFG6qt7SLc=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/github.min.css crossorigin=anonymous title=hl-light><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/dracula.min.css crossorigin=anonymous title=hl-dark disabled><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.min.css integrity="sha512-1xoFisiGdy9nvho8EgXuXvnpR5GAMSjFwp40gSRE3NwdUdIMIKuPa7bqoUhLD0O/5tPNhteAsE5XyyMi5reQVA==" crossorigin=anonymous><script src=https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.2.2/lazysizes.min.js integrity="sha512-TmDwFLhg3UA4ZG0Eb4MIyT1O1Mb+Oww5kFG0uHqXsdbyZz9DcvYQhKpGgNkamAI6h2lGGZq2X8ftOJvF/XjTUg==" crossorigin=anonymous async></script><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js integrity crossorigin=anonymous async></script><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,400i%7CKarla:400,400i,700,700i%7CRoboto+Mono&display=swap"><link rel=stylesheet href=../../css/wowchemy.css><link rel=manifest href=../../index.webmanifest><link rel=icon type=image/png href=../../images/icon_hu0365f2187e15210a9118469a64220edc_142871_32x32_fill_lanczos_center_2.png><link rel=apple-touch-icon type=image/png href=../../images/icon_hu0365f2187e15210a9118469a64220edc_142871_192x192_fill_lanczos_center_2.png><link rel=canonical href=https://rsouthern.github.io/post/mls/><meta property="twitter:card" content="summary_large_image"><meta property="og:site_name" content="Richard's Blog"><meta property="og:url" content="https://rsouthern.github.io/post/mls/"><meta property="og:title" content="n-Dimensional Moving Least Squares projection | Richard's Blog"><meta property="og:description" content="An implementation of N-Dimensional Moving Least Squares on point clouds in C++."><meta property="og:image" content="https://rsouthern.github.io/post/mls/featured.png"><meta property="twitter:image" content="https://rsouthern.github.io/post/mls/featured.png"><meta property="og:locale" content="en-uk"><meta property="article:published_time" content="2016-04-01T00:00:00+00:00"><meta property="article:modified_time" content="2016-04-01T00:00:00+00:00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://rsouthern.github.io/post/mls/"},"headline":"n-Dimensional Moving Least Squares projection","image":["https://rsouthern.github.io/post/mls/featured.png"],"datePublished":"2016-04-01T00:00:00Z","dateModified":"2016-04-01T00:00:00Z","author":{"@type":"Person","name":"Richard Southern"},"publisher":{"@type":"Organization","name":"Richard's Blog","logo":{"@type":"ImageObject","url":"https://rsouthern.github.io/images/icon_hu0365f2187e15210a9118469a64220edc_142871_192x192_fill_lanczos_center_2.png"}},"description":"An implementation of N-Dimensional Moving Least Squares on point clouds in C++."}</script><title>n-Dimensional Moving Least Squares projection | Richard's Blog</title></head><body id=top data-spy=scroll data-offset=70 data-target=#TableOfContents><script>window.wcDarkLightEnabled=true;</script><script>const isSiteThemeDark=false;</script><script src=../../js/load-theme.js></script><aside class=search-results id=search><div class=container><section class=search-header><div class="row no-gutters justify-content-between mb-3"><div class=col-6><h1>Search</h1></div><div class="col-6 col-search-close"><a class=js-search href=#><i class="fas fa-times-circle text-muted" aria-hidden=true></i></a></div></div><div id=search-box><input name=q id=search-query placeholder=Search... autocapitalize=off autocomplete=off autocorrect=off spellcheck=false type=search class=form-control></div></section><section class=section-search-results><div id=search-hits></div></section></div></aside><nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id=navbar-main><div class=container><div class="d-none d-lg-inline-flex"><a class=navbar-brand href=../../>Richard's Blog</a></div><button type=button class=navbar-toggler data-toggle=collapse data-target=#navbar-content aria-controls=navbar aria-expanded=false aria-label="Toggle navigation">
<span><i class="fas fa-bars"></i></span></button><div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none"><a class=navbar-brand href=../../>Richard's Blog</a></div><div class="navbar-collapse main-menu-item collapse justify-content-start" id=navbar-content><ul class="navbar-nav d-md-inline-flex"><li class=nav-item><a class=nav-link href=../../#about><span>Home</span></a></li><li class=nav-item><a class=nav-link href=../../#publications><span>Publications</span></a></li><li class=nav-item><a class=nav-link href=../../#posts><span>Posts</span></a></li><li class=nav-item><a class=nav-link href=../../#talks><span>Talks</span></a></li></ul></div><ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2"><li class=nav-item><a class="nav-link js-search" href=# aria-label=Search><i class="fas fa-search" aria-hidden=true></i></a></li><li class="nav-item dropdown theme-dropdown"><a href=# class=nav-link data-toggle=dropdown aria-haspopup=true><i class="fas fa-moon" aria-hidden=true></i></a><div class=dropdown-menu><a href=# class="dropdown-item js-set-theme-light"><span>Light</span></a>
<a href=# class="dropdown-item js-set-theme-dark"><span>Dark</span></a>
<a href=# class="dropdown-item js-set-theme-auto"><span>Automatic</span></a></div></li></ul></div></nav><article class=article><div class="article-container pt-3"><h1>n-Dimensional Moving Least Squares projection</h1><div class=article-metadata><span class=article-date>Apr 1, 2016</span>
<span class=middot-divider></span><span class=article-reading-time>11 min read</span></div></div><div class="article-header article-container featured-image-wrapper mt-4 mb-4" style=max-width:577px;max-height:572px><div style=position:relative><img src=../../post/mls/featured.png alt class=featured-image></div></div><div class=article-container><div class=article-style><h3 id=background>Background</h3><p>Continuing with the theme of nD implementations of useful algorithms, here is my take on <a href=https://en.wikipedia.org/wiki/Moving_least_squares>Moving Least Squares (MLS)</a>, a popular method used in engineering and graphics applications for smoothing out noisy point cloud data. Possibly data sources include laser scans, depth sensors (e.g. Kinect) or the like.</p><p>The basic principle of MLS projection is that you have a <em>noisy point cloud</em> approximating a <em>surface</em>. Projection means we&rsquo;re going to take a point from anywhere in space and project it on this surface approximation. We will conveniently also get a surface normal for free as a result of doing this.</p><h3 id=the-basic-algorithm>The Basic Algorithm</h3><p>I&rsquo;ll describe the projection algorithm with reference to the following figures:</p><table width=100%><tr><td><img width=100% src=mlsproject1.svg></td><td><img width=100% src=mlsproject2.svg></td><td><img width=100% src=mlsproject3.svg></td></tr></table>We are given the original query site \\(q_0)\in\mathbb{R}^n\\) (the red point) and the existing point cloud consisting of points \\(x_i \in \mathbb{R}^n\\) (the black points) (note I'm going to use the indices of the query site and the point cloud differently - the index of \\(q\\) refers to the iteration number of the algorith, the index of \\(x\\) will refer to index of the nearby points). We are also given some query radius \\(r\\) which will contain all the points of interest. Note that the choice of \\(r\\) has a significant effect on the smoothness of the function - this will probably be a topic of discussion for a later post. In the images from right to left:
1. Identify all the points within the query radius \\(r\\) of \\(q_0\\), i.e. the set of points \\(\\{x_i : \\|x_i - q_0\\| < r\\}\\)
2. Construct a *best-fit plane* through these points by using a weighted least squares method (more on this later). Then *project* \\(q_0\\) onto this plane to find our next query point \\(q_1\\).
3. Iterate and continue until two consecutive steps of the projection result in very similar points, i.e. within some \\(\epsilon\\) which is some small error tolerance.<p>This is pretty trivially demonstrated using a code snippet from the implementation. In this example <em>cpt</em> is the current point (e.g. the iterating projected point \(q_j\)), <em>tol</em> is some user specified tolerance (equivalent to \(\epsilon\)). The rest should mostly be self-explanatory:</p><pre><code class=language-cpp>    // Continue this loop until we're close enough to the surface
    while (err &gt; tol) {
        // Perform a least squares projection from the current point onto a best
        // fit hyperplane. The result will tell us if any neighbours were found.
        if (weightedLS(cpt, radius, plane, idxDist) == 0) {
            // What should we do here? throw an error?
            return cpt;
	}
        // If it all went well, we'll have a plane onto which the point can be projected
        tmp = plane.projection(cpt);

        // Our error is just the distance between the input point and our current point
        err = (tmp-cpt).norm();

        // Update our current point to the projected point
        cpt = tmp;
    }

    // If it all went well, we can assume our current point is the best one available
    return cpt;
</code></pre><p>Note that the function weightedLS() returns the number of points found within the query radius, and modifies the plane to contain the best fit plan through the points. If nothing was found within the radius there is a question of what you should do. Increasing the radius size is an obvious choice, but there may be continuity issues in the query data set.</p><h3 id=weighted-least-squares>Weighted Least Squares</h3><p>So it is now important to drill down into the Weighted Least Squares fit function. There are some pretty useful references on everyones favourite academic source <a href=https://en.wikipedia.org/wiki/Least_squares#Weighted_least_squares>here</a>. There is a much broader discussion here to be had about linear regression for fitting curves to polynomials, but I&rsquo;ll restrict myself to the planar case.</p><p>The general implicit form for a plane $$\mathbf{n}\cdot(x - x_0)=0,$$ where \(\mathbf{n}\) is a normal to the plane (bold because it is a vector), and \(x_0\) is a point through which the plane passes. So the plane is defined by any point \(x\) for which the above function evaluates to exactly \(0\).</p><p>If the number of points is equal to the dimensionality the space it is easy enough to find the normal from the input points. For example, the normal to a vector
$$
\mathbf{v}= \left[ \begin{array}\ x_1 - x_0 \\ y_1 - y_0 \end{array} \right]
$$
between two points in \(\mathbb{R}^2\) is \((-v_y,v_x)\), for higher dimensions use the cross or wedge product.</p><blockquote><p>As an aside, you might be interested to know that this can also be solved by solving for the <em>null space</em> of the system of equations given by \(\mathbf{n}\cdot(x - x_0)=0\) - recall that this system is underdetermined because one of the points provided will be \(x_0\). In \(\mathbb{R}^2\), this will be the equivalent of solving for the <em>null space</em> of
$$
\begin{array}\<br>\mathbf{n} \cdot \mathbf{v} = 0\<br>n_x v_x + n_y v_y = 0
\end{array}
$$
which is of course only non-trivially true when \(\mathbf{n} = (-\mathbf{v}_y,\mathbf{v}_x)\).</p></blockquote><p>Note that we can also solve for the normal using the formula \(\mathbf{n}\cdot(x - x_0)=\alpha\) where \(\alpha\) is some arbitrary scalar as the normal is the same if we shifted it along the normal direction. This allows us to formulate the problem into a linear system
$$X\textbf{n}=\textbf{b},$$
where \(X\) is the matrix of known points on the plane, \(\mathbf{n}\) is the unknown plane normal, and \(\mathbf{b}\) is some constant vector made up of \(\alpha\)&lsquo;s. For simplicity let&rsquo;s just let \(\alpha=1\) from now on. This is well defined if \(X\) is square, i.e. there are the same number of points as there are dimensions - this is because these points form a <a href=https://en.wikipedia.org/wiki/Simplex>n-simplex</a> in \(\mathbb{R}^n\).</p><p>Ok, now what happens if we have more points than dimensions? In this case, we can solve this in the <em>least squares sense</em>. This is essentially an optimisation problem, solved using the Moore-Penrose <a href=https://en.wikipedia.org/wiki/Least_squares>pseudoinverse</a>. While there is buckets to write about this, it boils down to premultiplying both sides of the equation by \(X^T\) yielding
$$X^T X \mathbf{n} = X^T \mathbf{b}.$$
Note that \(X^T X\) is now a square matrix, the system can be solved and has a unique solution. The solution itself is optimal in a least-squares sense, meaning that it <em>minimizes the sum of the squares of the errors made in the results of each equation</em>. Or put another way, it spreads the error love evenly between all of the point contributors to the plane.</p><p>Now applying weights to this should actually be quite straightforward: we&rsquo;ll create some diagonal matrix of weights \(W\) where elements on the diagonal represent the amount we want to <em>weight the error</em> of each point in \(X\). So a smaller weight would mean that in a least squares sense we are consider the error to be less important. This is incorporated into the system above as follows:
$$X^T W X \mathbf{n} = X^T W \mathbf{b}.$$
If we&rsquo;re trying to write our plane equation as \(\mathbf{n}\cdot x = d\) where \(d\) is a constant, a property of the above process is that \(d=1 / |\mathbf{n}| \). Also you must still normalise the resultant normal, e.g. \(\mathbf{n} = \mathbf{n}d\). Note that this whole process works in any dimension - pretty neat.</p><p>There is also the small issue of how to decide on the weights. Any kernel function would do, and each will have an impact on the overall quality of the reconstruction. Currently I&rsquo;m just inverting the distance, but this could lead to problems when the point is exactly on top of the query point. Other choices of kernel function, such as \(\exp({-s^2})\). Some experimentation depending on application will probably be required.</p><p>Here is the implementation of this in <em>pointcloud.hpp</em>:</p><pre><code class=language-cpp>    if (m_index.findNeighbors(results, pt.data(), nanoflann::SearchParams())) {
        // Weights matrix
        MatrixXr W(idxDist.size(), idxDist.size()); W.setZero();
        // The matrix of the actual points
        MatrixXr K(idxDist.size(), DIM);

        // The result of the call is true if a neighbour could be found
        typename ResultsVector::iterator it;
        int i,j;
        for (it = idxDist.begin(), i=0; it != idxDist.end(); ++it,++i) {
            // First check to see if this evaluates to 0 exactly (BAD)
            if ((*it).second == REAL(0)) {
                // Set the weight to half the max REAL value (risky)
                W(i,i) = std::numeric_limits&lt;REAL&gt;::max() * REAL(0.5);
            } else {
                // Set the weight to the inverse distance
                W(i,i) = 1.0 / (*it).second;
            }
            // Build the matrix K out of the point data
            for (j=0;j&lt;DIM;++j) K(i,j) = m_data[(*it).first][j];
        }
        // Normalise the weights to make sure they sum to 1
        W = W / W.sum();

        // Now solve the system using the following formula from MATLAB
        // N' = (K'*diag(W)*K) \ (K')*diag(W)*(-ones(size(I,1),1));
        // d  = 1/norm(N);
        // N  = N' * d;
        VectorDr ans;
        MatrixXr A = K.transpose() * W * K;
        VectorDr b = -K.transpose() * W.diagonal();
        ans =  A.llt().solve(b);
        REAL d = REAL(1) / ans.norm();
        Hyperplane _h(ans * d, d);
        h = _h;

        // For the results structure to be useful we need it to store the weights from W, so
        // we copy these back into it
        for (it = idxDist.begin(), i=0; it != idxDist.end(); ++it,++i) {
            (*it).second = W(i,i);
        }
        // We return the number of effective matches
        return idxDist.size();
    } else {
        // No neighbours found! What do we do?
        return 0;
    }
</code></pre><p>The general dimensional hyperplane is managed by <a href=http://eigen.tuxfamily.org/dox/classEigen_1_1Hyperplane.html>Eigen::Hyperplane</a> which allows us to do projections (see previous code snippet). Note that the solver used is Eigen&rsquo;s Cholesky solver, which is very fast by requires a matrix that is symmetric positive definite. Fortunately our matrix \(X^T W X\) has these properties. In practice it is very unwise to solve systems like \(A\textbf{x}=\textbf{b}\) by inverting \(A\).</p><h3 id=implementation-details>Implementation details</h3><p>The plan was to make this implementation general dimensional, and this has been achieved through liberal use of templates.</p><pre><code class=language-cpp>template &lt;typename REAL, unsigned int DIM&gt;
class PointCloud {
</code></pre><p>The top of our class says that we&rsquo;re allowing you to choose your type to represent the data (called REAL) and the dimension of the data set, which can be anything you like. As mentioned previously, Eigen provides general dimensional hyperplane routines which makes our lives relatively simple.</p><p>Unfortunately as you may have realised from the above algorithm the performance is largely dependent on how quickly we can find all the points within a given radius. This is resolved using a <a href=https://en.wikipedia.org/wiki/K-d_tree>KD tree</a>, which essentially organises the points into a graph structure for fast searching. I&rsquo;m not going to discuss the specifics of KD tree construction and querying - there are plenty of other links to help you with this. I chose to make use of <a href=https://github.com/jlblancoc/nanoflann>nanoflann</a> from Jose Luis Blanco-Claraco as it is a header only library making it easier to incorporate into the project build.</p><p>One issue which may seem non-obvious is that I have added the KD tree index object as a member of the PointCloud class:</p><pre><code class=language-cpp>    /// A KDTreeIndex type
    typedef nanoflann::KDTreeSingleIndexAdaptor&lt;
        nanoflann::L2_Simple_Adaptor&lt;REAL, PointCloud&lt;REAL,DIM&gt; &gt; ,
        PointCloud&lt;REAL,DIM&gt;,
        DIM&gt; KDTreeIndex;

    /// A KDTree structure
    KDTreeIndex m_index;
</code></pre><p>This means that the KDTreeIndex is incorporated into the PointCloud class, although as you can see from the typedef above the PointCloud is a template parameter for the index itself. This is because the class which is passed to nanoflann needs to have a set of functions (all with the prefix kdtree_) which will be called during kd tree construction and querying, for example:</p><pre><code class=language-cpp>    /// Returns the dim'th component of the idx'th point in the class (random point access)
    inline REAL kdtree_get_pt(const size_t idx, int dim) const {
        return m_data[idx][dim];
    }
</code></pre><p>The way this works is that we pass <strong>this</strong> object when we construct the KDTreeIndex, e.g.</p><pre><code class=language-cpp>/**
 * Build an empty point cloud with an empty KDTree.
 */
template &lt;typename REAL, unsigned int DIM&gt;
PointCloud&lt;REAL,DIM&gt;::PointCloud()
    : m_index(DIM, *this, nanoflann::KDTreeSingleIndexAdaptorParams(10)) {
}
</code></pre><p>It is an interesting and rather twisting compositional arrangement, but it allows us to make sure that all the elements relevent to the point cloud in one convenient place.</p><p>Another interesting trick of nanoflann compatibility is the fact that I&rsquo;m storing my points in Eigen, while nanoflann needs to compute distances using data stored in pointers to REAL&rsquo;s. Rather than constructing a new Eigen point and copy data across, we can make use of the <a href=http://eigen.tuxfamily.org/dox/classEigen_1_1Map.html>Eigen::Map</a> which will just make a vector out of the existing memory rather than copying it across, hopefully saving us a couple of clocks:</p><pre><code class=language-cpp>    /// Returns the distance between the vector &quot;p1[0:size-1]&quot; and the data point with index &quot;idx_p2&quot; stored in the class:
    inline REAL kdtree_distance(const REAL *p1_data, const size_t idx_p2, size_t size) const {
        Eigen::Map&lt;const PointType&gt; p1_map(p1_data,DIM);
        return (m_data[idx_p2] - p1_map).norm();
    }
</code></pre><h3 id=conclusions>Conclusions</h3><p>Currently the examples of using this code are pretty spartan as it is going to be incorporate into a significantly larger project. However, there are a couple of important things to note about this implementation:</p><ol><li>The choice of radius has a significant impact on the projection. In previous implementations I&rsquo;ve geometrically scaled the radius until some points are found and then scaled it back after the first projection. However, this may have continuity implications. I&rsquo;ve also used a precomputed smooth scalar field of radii to use for this projection to ensure that you have a constant number of neighbours - something I&rsquo;ll be experimenting with in the future.</li><li>There are a couple of implementation issues I still need to resolve, such as the choice of weight function and how to handle the situation when there are no neighbours in the specificed radius (see above). There is also the relationship between the radius and the cell size of the KD Tree which needs to be resolved. And some nice 3D examples!</li><li>The process of using MLS projection to smooth input data (called <em>mollification</em>) was not discussed, but will hopefully be appended to this post at some point. The process is pretty simple: project each point in the existing set onto other points in the same set. This has some interesting performance considerations to doing it correctly (for example, the KD Tree will need to be rebuilt in each iteration).</li><li>Parallelism! There are a couple of things which could be done in parallel, especially if we&rsquo;re doing mollification.</li></ol><h3 id=downloads>Downloads</h3><p>The source code is hosted on <a href=https://github.com/rsouthern/Examples>GitHub</a>. Clone it from the repository using the following command from your console:</p><pre><code class=language-shell>git clone https://github.com/rsouthern/Examples
</code></pre></div><div class=article-tags><a class="badge badge-light" href=../../tag/c-/>c++</a>
<a class="badge badge-light" href=../../tag/geometry-processing/>geometry processing</a>
<a class="badge badge-light" href=../../tag/parameterization/>parameterization</a></div><div class=share-box aria-hidden=true><ul class=share><li><a href="https://twitter.com/intent/tweet?url=https://rsouthern.github.io/post/mls/&text=n-Dimensional%20Moving%20Least%20Squares%20projection" target=_blank rel=noopener class=share-btn-twitter><i class="fab fa-twitter"></i></a></li><li><a href="https://www.facebook.com/sharer.php?u=https://rsouthern.github.io/post/mls/&t=n-Dimensional%20Moving%20Least%20Squares%20projection" target=_blank rel=noopener class=share-btn-facebook><i class="fab fa-facebook"></i></a></li><li><a href="mailto:?subject=n-Dimensional%20Moving%20Least%20Squares%20projection&body=https://rsouthern.github.io/post/mls/" target=_blank rel=noopener class=share-btn-email><i class="fas fa-envelope"></i></a></li><li><a href="https://www.linkedin.com/shareArticle?url=https://rsouthern.github.io/post/mls/&title=n-Dimensional%20Moving%20Least%20Squares%20projection" target=_blank rel=noopener class=share-btn-linkedin><i class="fab fa-linkedin-in"></i></a></li><li><a href="whatsapp://send?text=n-Dimensional%20Moving%20Least%20Squares%20projection%20https://rsouthern.github.io/post/mls/" target=_blank rel=noopener class=share-btn-whatsapp><i class="fab fa-whatsapp"></i></a></li><li><a href="https://service.weibo.com/share/share.php?url=https://rsouthern.github.io/post/mls/&title=n-Dimensional%20Moving%20Least%20Squares%20projection" target=_blank rel=noopener class=share-btn-weibo><i class="fab fa-weibo"></i></a></li></ul></div><div class="media author-card content-widget-hr"><a href=https://rsouthern.github.io/><img class="avatar mr-3 avatar-circle" src=../../author/richard-southern/avatar_hu8b4b6ae9a405f1b6aee3b6ae457da189_173063_270x270_fill_q90_lanczos_center.jpg alt="Richard Southern"></a><div class=media-body><h5 class=card-title><a href=https://rsouthern.github.io/>Richard Southern</a></h5><h6 class=card-subtitle>Lead Developer</h6><p class=card-text>Leader, Graphics Researcher, Software Engineer</p><ul class=network-icon aria-hidden=true><li><a href=https://github.com/rsouthern target=_blank rel=noopener><i class="fab fa-github"></i></a></li><li><a href=https://www.linkedin.com/in/richard-southern-70289b12/ target=_blank rel=noopener><i class="fab fa-linkedin"></i></a></li><li><a href=../../Downloads/cv.pdf><i class="ai ai-cv"></i></a></li></ul></div></div><div class="article-widget content-widget-hr"><h3>Related</h3><ul><li><a href=../../post/scalarfield/>Recursive n-dimensional scalar field interpolation</a></li><li><a href=../../post/fdm/>The Force Density Method - A Brief Introduction</a></li><li><a href=../../publication/skinslide/>Fast simulation of skin sliding</a></li><li><a href=../../post/noisetexture/>A Templated Implementation of Noise Texture</a></li><li><a href=../../publication/cagebased/>Automatic cage construction for retargeted muscle fitting</a></li></ul></div></div></article><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/instant.page/5.1.0/instantpage.min.js integrity="sha512-1+qUtKoh9XZW7j+6LhRMAyOrgSQKenQ4mluTR+cvxXjP1Z54RxZuzstR/H9kgPXQsVB8IW7DMDFUJpzLjvhGSQ==" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/highlight.min.js integrity="sha512-TDKKr+IvoqZnPzc3l35hdjpHD0m+b2EC2SrLEgKDRWpxf2rFCxemkgvJ5kfU48ip+Y+m2XVKyOCD85ybtlZDmw==" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/r.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/c++.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.min.js integrity="sha512-SeiQaaDh73yrb56sTW/RgVdi/mMqNeM2oBwubFHagc5BkixSpP1fvqF47mKzPGWYSSy4RwbBunrJBQ4Co8fRWA==" crossorigin=anonymous></script><script>const code_highlighting=true;</script><script>const search_config={"indexURI":"/index.json","minLength":1,"threshold":0.3};const i18n={"no_results":"No results found","placeholder":"Search...","results":"results found"};const content_type={'post':"Posts",'project':"Projects",'publication':"Publications",'talk':"Talks",'slides':"Slides"};</script><script id=search-hit-fuse-template type=text/x-template>
      <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
      </div>
    </script><script src=https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin=anonymous></script><script src=../../js/wowchemy.min.4c2bca31150ce93c5a5e43b8a50f22fd.js></script><div class=container><footer class=site-footer><p class=powered-by></p><p class=powered-by>Published with
<a href=https://wowchemy.com target=_blank rel=noopener>Wowchemy</a> —
the free, <a href=https://github.com/wowchemy/wowchemy-hugo-modules target=_blank rel=noopener>open source</a> website builder that empowers creators.
<span class=float-right aria-hidden=true><a href=# class=back-to-top><span class=button_icon><i class="fas fa-chevron-up fa-2x"></i></span></a></span></p></footer></div><div id=modal class="modal fade" role=dialog><div class=modal-dialog><div class=modal-content><div class=modal-header><h5 class=modal-title>Cite</h5><button type=button class=close data-dismiss=modal aria-label=Close>
<span aria-hidden=true>&#215;</span></button></div><div class=modal-body><pre><code class="tex hljs"></code></pre></div><div class=modal-footer><a class="btn btn-outline-primary my-1 js-copy-cite" href=# target=_blank><i class="fas fa-copy"></i>Copy</a>
<a class="btn btn-outline-primary my-1 js-download-cite" href=# target=_blank><i class="fas fa-download"></i>Download</a><div id=modal-error></div></div></div></div></div></body></html>