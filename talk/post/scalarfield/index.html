<!doctype html><html lang=en-uk><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Wowchemy 4.8.0 for Hugo"><meta name=author content="Richard Southern"><meta name=description content="A recursive implementation of N-Dimensional Catmull Rom spline interpolation for general scalar fields in C++."><link rel=alternate hreflang=en-uk href=https://rsouthern.github.io/post/scalarfield/><link rel=preconnect href=https://fonts.gstatic.com crossorigin><meta name=theme-color content="#2962ff"><script src=../../js/mathjax-config.js></script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css integrity="sha256-FMvZuGapsJLjouA6k7Eo2lusoAX9i0ShlWFG6qt7SLc=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/github.min.css crossorigin=anonymous title=hl-light><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/dracula.min.css crossorigin=anonymous title=hl-dark disabled><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.min.css integrity="sha512-1xoFisiGdy9nvho8EgXuXvnpR5GAMSjFwp40gSRE3NwdUdIMIKuPa7bqoUhLD0O/5tPNhteAsE5XyyMi5reQVA==" crossorigin=anonymous><script src=https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.2.2/lazysizes.min.js integrity="sha512-TmDwFLhg3UA4ZG0Eb4MIyT1O1Mb+Oww5kFG0uHqXsdbyZz9DcvYQhKpGgNkamAI6h2lGGZq2X8ftOJvF/XjTUg==" crossorigin=anonymous async></script><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js integrity crossorigin=anonymous async></script><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,400i%7CKarla:400,400i,700,700i%7CRoboto+Mono&display=swap"><link rel=stylesheet href=../../css/wowchemy.css><link rel=manifest href=../../index.webmanifest><link rel=icon type=image/png href=../../images/icon_hu0365f2187e15210a9118469a64220edc_142871_32x32_fill_lanczos_center_2.png><link rel=apple-touch-icon type=image/png href=../../images/icon_hu0365f2187e15210a9118469a64220edc_142871_192x192_fill_lanczos_center_2.png><link rel=canonical href=https://rsouthern.github.io/post/scalarfield/><meta property="twitter:card" content="summary_large_image"><meta property="og:site_name" content="Richard's Blog"><meta property="og:url" content="https://rsouthern.github.io/post/scalarfield/"><meta property="og:title" content="Recursive n-dimensional scalar field interpolation | Richard's Blog"><meta property="og:description" content="A recursive implementation of N-Dimensional Catmull Rom spline interpolation for general scalar fields in C++."><meta property="og:image" content="https://rsouthern.github.io/post/scalarfield/featured.png"><meta property="twitter:image" content="https://rsouthern.github.io/post/scalarfield/featured.png"><meta property="og:locale" content="en-uk"><meta property="article:published_time" content="2015-09-19T00:00:00+00:00"><meta property="article:modified_time" content="2015-09-19T00:00:00+00:00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://rsouthern.github.io/post/scalarfield/"},"headline":"Recursive n-dimensional scalar field interpolation","image":["https://rsouthern.github.io/post/scalarfield/featured.png"],"datePublished":"2015-09-19T00:00:00Z","dateModified":"2015-09-19T00:00:00Z","author":{"@type":"Person","name":"Richard Southern"},"publisher":{"@type":"Organization","name":"Richard's Blog","logo":{"@type":"ImageObject","url":"https://rsouthern.github.io/images/icon_hu0365f2187e15210a9118469a64220edc_142871_192x192_fill_lanczos_center_2.png"}},"description":"A recursive implementation of N-Dimensional Catmull Rom spline interpolation for general scalar fields in C++."}</script><title>Recursive n-dimensional scalar field interpolation | Richard's Blog</title></head><body id=top data-spy=scroll data-offset=70 data-target=#TableOfContents><script>window.wcDarkLightEnabled=true;</script><script>const isSiteThemeDark=false;</script><script src=../../js/load-theme.js></script><aside class=search-results id=search><div class=container><section class=search-header><div class="row no-gutters justify-content-between mb-3"><div class=col-6><h1>Search</h1></div><div class="col-6 col-search-close"><a class=js-search href=#><i class="fas fa-times-circle text-muted" aria-hidden=true></i></a></div></div><div id=search-box><input name=q id=search-query placeholder=Search... autocapitalize=off autocomplete=off autocorrect=off spellcheck=false type=search class=form-control></div></section><section class=section-search-results><div id=search-hits></div></section></div></aside><nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id=navbar-main><div class=container><div class="d-none d-lg-inline-flex"><a class=navbar-brand href=../../>Richard's Blog</a></div><button type=button class=navbar-toggler data-toggle=collapse data-target=#navbar-content aria-controls=navbar aria-expanded=false aria-label="Toggle navigation">
<span><i class="fas fa-bars"></i></span></button><div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none"><a class=navbar-brand href=../../>Richard's Blog</a></div><div class="navbar-collapse main-menu-item collapse justify-content-start" id=navbar-content><ul class="navbar-nav d-md-inline-flex"><li class=nav-item><a class=nav-link href=../../#about><span>Home</span></a></li><li class=nav-item><a class=nav-link href=../../#publications><span>Publications</span></a></li><li class=nav-item><a class=nav-link href=../../#posts><span>Posts</span></a></li><li class=nav-item><a class=nav-link href=../../#talks><span>Talks</span></a></li></ul></div><ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2"><li class=nav-item><a class="nav-link js-search" href=# aria-label=Search><i class="fas fa-search" aria-hidden=true></i></a></li><li class="nav-item dropdown theme-dropdown"><a href=# class=nav-link data-toggle=dropdown aria-haspopup=true><i class="fas fa-moon" aria-hidden=true></i></a><div class=dropdown-menu><a href=# class="dropdown-item js-set-theme-light"><span>Light</span></a>
<a href=# class="dropdown-item js-set-theme-dark"><span>Dark</span></a>
<a href=# class="dropdown-item js-set-theme-auto"><span>Automatic</span></a></div></li></ul></div></nav><article class=article><div class="article-container pt-3"><h1>Recursive n-dimensional scalar field interpolation</h1><div class=article-metadata><span class=article-date>Sep 19, 2015</span>
<span class=middot-divider></span><span class=article-reading-time>9 min read</span></div></div><div class="article-header container-fluid featured-image-wrapper mt-4 mb-4" style=max-width:500px;max-height:500px><div style=position:relative><img src=../../post/scalarfield/featured.png alt class=featured-image></div></div><div class=article-container><div class=article-style><h3 id=background>Background</h3><p>Lets say you have a smooth scalar function of any number of variables \(f:\mathbb{R}^n\mapsto\mathbb{R}^1\). Let&rsquo;s assume that the function is computationally expensive to evaluate, but you need to do this at run-time, possibly a lot. Let&rsquo;s also assume that you can define the maximum and minimum range of values which you are interested in. Let&rsquo;s also assume that the function is smooth, and you&rsquo;re tolerant of (or even prefer) the results to be smoothed over.</p><p>One possible solution is to sample values of the function over a regular grid, and perform some sort of interpolation between the values. So we&rsquo;ll define a different function
\(g:\mathbb{R}^n\mapsto\mathbb{R}^1,,g\approx f\). Depending on the desired smoothness of the approximation different interpolation functions are feasible, but not all of these generalise to any dimension. One method which does, however, is the <a href=https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline>Catmull-Rom Spline</a> (co-invented by the CG superhero <a href=https://en.wikipedia.org/wiki/Edwin_Catmull>Ed Catmull</a>) which can be evaluated recursively on grid edges and exhibits \(C^2\) continuity.</p><p>I&rsquo;ll explain how this works with the help of this figure, representing a 2D scalar field:</p><center><img src=catmullrom_interpolation.svg></center>
In this case, we're looking at a function $f:\mathbb{R}^2\mapsto\mathbb{R}^1$ with the value returned by this function visualised as a height above the $(x,y)$ grid in the above image. We assume that the red points are the pre-computed values for $f$ at the corners of the grid cells. Once the cell in which the value to be calculated is identified, 4 Catmull-Rom interpolations are performed in the $y$ direction, to find the green points. One further Catmull-Rom interpolation is needed between these points to compute the final interpolated value (in blue). Note that the number of curves that need to interpolated in each dimension is multiplied by 4 in each step (so on a 3D grid, the first step requires 16 interpolations in the $z$, then 4 in the $y$ and 1 in the $x$). You can see that this process is ripe for recursion. It is also ripe for parallel computation, but that is another story...<h3 id=applications>Applications</h3><p>You might be wondering when you might you want to use an application like this? I developed it in the context of a sparse, high dimensional <a href=https://en.wikipedia.org/wiki/Moving_least_squares>Moving Least Squares</a> projection: if you are projecting onto a point cloud that is irregular, you need an adaptive, variable radius function in order to ensure that you have sufficient local points on which to project. As it&rsquo;s expensive to compute local neighbours at run time (especially in, say, 66 dimensions) it&rsquo;s probably a good idea to define an approximating smooth function which, given any point in space, returns a radius that will probably contain a desired number of point samples.</p><h3 id=implementation>Implementation</h3><p>There are a number of features used in this implementation, which I&rsquo;m going to unpick from the implementation and discuss separately.</p><h4 id=passing-around-functions>Passing around functions</h4><p>Fundamental to this process is the ability to evaluate a generic function at a point. It would be very convenient for us to be able to pass said function around as a generic function pointer. For a simple generic function signature, I&rsquo;ll use a function that accepts an array of <em>double</em>s, and returns a <em>double</em>. This can be stated using the <a href=http://en.cppreference.com/w/cpp/utility/functional/function>std::function</a> method:</p><pre><code class=language-cpp>std::function&lt;double (double*)&gt; _func;
</code></pre><p>Note that the type notation is C notation for a function that accepts a pointer to a double, and returns a double. This makes <em>_func</em> a generic function that can be passed as a parameter - particularly convenient if we&rsquo;re allowing the use of arbitrary input functions. Of course, the return type and array size could be specified as template parameters, but for interaction with existing functions (e.g. libnoise) I&rsquo;ve kept it simple.</p><h4 id=templates-and-c11>Templates and C++11</h4><p>I do, however, use templates for the actual ScalarField class. In an early implementation of this structure I just used dynamic arrays of doubles to store the data - but this gives us the overhead of dynamic allocation and deallocation, along with the risks associated with non-contiguous memory. <em>C++11</em> introduces the <em>std::array</em>, which is essentially an old skool <em>C</em> static array, but with all the handy goodness of the STL.</p><p>This is from the top of the ScalarField class:</p><pre><code class=language-cpp>template &lt;uint DIM&gt;
class ScalarField {
public:
    /// Unsigned int array
    typedef std::array&lt;uint, DIM&gt; uintArray;

    /// Double array
    typedef std::array&lt;double, DIM&gt; doubleArray;
</code></pre><p>The template parameter is evaluated at <em>compile time</em>, generating a template class for the desired dimension. Whenever I create an object of type <em>doubleArray</em> in the code, this is done statically.</p><p>Note that I could have given a template parameter for a <em>real type</em> and an <em>integer type</em>, but that will add some unnecessary complexity for now.</p><h4 id=recursive-algorithm>Recursive Algorithm</h4><p>The core of the algorithm is the construction of the grid and the recursive evaluation of the query point. Fortunately these are reasonably similar. Lets have a look at the init routine:</p><pre><code class=language-cpp>/**
 * @brief ScalarField::initialise Inits the scalar field
 * @param _func A boost-ified function declaration which returns the scalar value
 * @param _minValue The minimum values of our given field.
 * @param _maxValue The maximum values of our given field.
 * @param _resolution The resolution of the field in each dimension.
 */
template&lt;uint DIM&gt;
void ScalarField&lt;DIM&gt;::init(std::function&lt;double (double*)&gt; _func,
							const doubleArray &amp;_minValue,
							const doubleArray &amp;_maxValue,
							sconst uintArray&amp; _resolution) {
    // Check we've not been here before already
    if (m_isInit) cleanup();

    // Precompute the partition size in each case

    // Now we can allocate some memory for our data

    // Now for each value in the field we can use the provided function to derive the scalar value
    // this is done recursively (could easily be done in parallel
    doubleArray pos; uintArray idx;
    initRecurse(_func, 0u, idx, pos);

    // Set this to initialised
    m_isInit = true;
}
</code></pre><p>Not very much excitement there: we set up the memory and ready ourselves for running the recursive function. The initRecurse function is obviously where the action is - so I&rsquo;ll break it down into stages:</p><pre><code class=language-cpp>/**
 * @brief ScalarField::initRecurse Recursively initialise the scalar field along each dimension.
 * @param _func The boostified function to execute to determine the scalar value
 * @param dim The current dimension (start this at 0)
 * @param idx The current index to evaluate (empty when you start)
 * @param pos The position to evaluate (empty when you start)
 */
template&lt;uint DIM&gt;
void ScalarField&lt;DIM&gt;::initRecurse(std::function&lt;double (double*)&gt; _func,
                                   const uint &amp;dim,
                                   uintArray &amp;idx,
                                   doubleArray &amp;pos) {
</code></pre><p>The prototype reveals a lot about the functionality of the function. The first parameter is the function that we want to call at the grid points. The second parameter is the current dimension. You&rsquo;ll notice from the code above that this starts at <em>0</em> - each time the function is called, the dimension number will tick up until it gets to the actual dimension, which is our recursion termination criteria. Index and the position values fill up after the recursion unrolls.</p><pre><code class=language-cpp>    // At the end of the recursion chain we can calculate the value using the function
    if (dim &gt;= DIM) {
        // First determine the index in the data
		...

        // Now set the value of the data in the right place to the result of the function
        m_data[dataIdx] = _func(&amp;pos[0]);

        return;
    }
</code></pre><p>At the end of the recursion chain, we evaluate the given function at the position. This isn&rsquo;t straightforward, as I&rsquo;ve stored all the data in a big flat 1D array. However I&rsquo;ve removed the details for simplicity.</p><p>If the function didn&rsquo;t return, we know that we&rsquo;re not at the end of the chain so we recursively evaluate across each grid dimension:</p><pre><code class=language-cpp>    // If we didn't get to the end of the chain, we run another iteration
    for (i = 0 ; i &lt; m_resolution[dim]; ++i) {
        idx[dim] = i;
        pos[dim] = m_minValue[dim] + i * m_partSize[dim];
        initRecurse(_func, dim+1, idx, pos);
    }
</code></pre><p>In this way, each node in each dimension is initialised with our input function.</p><p>The evaluation function is a bit more tricky:</p><pre><code class=language-cpp>/**
 * @brief ScalarField::eval Evaluate the scalar value at the specified point.
 * @param pt The position at which to evaluate the scalar field
 * @return
 */
template&lt;uint DIM&gt;
double ScalarField&lt;DIM&gt;::eval(const doubleArray&amp; pt) const {
    if (!m_isInit) return 0.0;

    // Determine the index of the bottom corner of the evaluation grid (if outside, extrapolation
    // may be used, so it's capped at the bounds of the grid)
	...

    // Deduce the index of the points from the min, max grid values and total resolution
	...

    // Evaluate the position recursively over all dimensions
    double ret_val = evalRecurse(0, idx, currentIdx, x);

    // Clear memory and return
    return ret_val;
}
</code></pre><p>This is largely the same as the <em>init</em> function above, except that you will need to calculate the bottom corner index of the grid cell in which the query point lives (which is messy, and hidden away).</p><p>The header for <em>evalRecurse</em> is more or less the same as <em>initRecurse</em> so I won&rsquo;t repeat myself. The big difference, of course, is that this function actually returns a value. Here&rsquo;s the termination condition:</p><pre><code class=language-cpp>    // The termination condition - just return the scalar value at the specified position
    if (dim &gt;= DIM) {

        // First determine the index in the data
		... 

        // Just return the data value at this position!
        return m_data[dataIdx];
    } 
</code></pre><p>This just returns the value at the grid point - this makes more sense in the context of the general condition below:</p><pre><code class=language-cpp>	else {
        // Evaluate the catmull rom spline recursively by combining the current indices
        // along all dimensions
        double v0, v1, v2, v3;
        currentIdx[dim] = idx[dim] + 0; v0 = evalRecurse(dim+1, idx, currentIdx, x);
        currentIdx[dim] = idx[dim] + 1; v1 = evalRecurse(dim+1, idx, currentIdx, x);
        currentIdx[dim] = idx[dim] + 2; v2 = evalRecurse(dim+1, idx, currentIdx, x);
        currentIdx[dim] = idx[dim] + 3; v3 = evalRecurse(dim+1, idx, currentIdx, x);
        return catmullRomSpline(x[dim], v0, v1, v2, v3);
    }
</code></pre><p>So this function spawns 4 different <em>evalRecurse</em>s for this thread, each one potentially spawning another 4 <em>ad nausium</em>. The results of each thread re interpolated using our magical <em>catmullRomSpline</em> function (which is really easy - check the code).</p><h3 id=conclusions>Conclusions</h3><p>This is a nice example of an bit of code that is useful for teaching and research: there are a couple of nice <em>C++11</em>, <em>C++</em> and <em>C</em> principles at play which greatly simplify the implementation and improve performance. The research behind it pretty nifty and broadly applicable (I would think).</p><p>You may have observed that you could use this approach for general dimensional mapping, i.e. $f:\mathbb{R}^n\mapsto\mathbb{R}^m$, assuming that you create <em>m</em> different ScalarFields. Vector Field intepolation might be more difficult as they will require some recombination function (e.g. normalisation), but not impossible.</p><p>Parallelism is an obviously missing thing here: in very high dimensional data sets this could prove to be particularly useful - it is essentially a <em>scan-reduce</em> function. Send me an email if you want this and I can check this out.</p><h3 id=downloads>Downloads</h3><p>The source code is hosted on <a href=https://github.com/rsouthern/Examples>GitHub</a>. Clone it from the repository using the following command from your console:</p><pre><code class=language-shell>git clone https://github.com/rsouthern/Examples
</code></pre></div><div class=article-tags><a class="badge badge-light" href=../../tag/c-/>c++</a>
<a class="badge badge-light" href=../../tag/geometry-processing/>geometry processing</a>
<a class="badge badge-light" href=../../tag/parameterization/>parameterization</a></div><div class=share-box aria-hidden=true><ul class=share><li><a href="https://twitter.com/intent/tweet?url=https://rsouthern.github.io/post/scalarfield/&text=Recursive%20n-dimensional%20scalar%20field%20interpolation" target=_blank rel=noopener class=share-btn-twitter><i class="fab fa-twitter"></i></a></li><li><a href="https://www.facebook.com/sharer.php?u=https://rsouthern.github.io/post/scalarfield/&t=Recursive%20n-dimensional%20scalar%20field%20interpolation" target=_blank rel=noopener class=share-btn-facebook><i class="fab fa-facebook"></i></a></li><li><a href="mailto:?subject=Recursive%20n-dimensional%20scalar%20field%20interpolation&body=https://rsouthern.github.io/post/scalarfield/" target=_blank rel=noopener class=share-btn-email><i class="fas fa-envelope"></i></a></li><li><a href="https://www.linkedin.com/shareArticle?url=https://rsouthern.github.io/post/scalarfield/&title=Recursive%20n-dimensional%20scalar%20field%20interpolation" target=_blank rel=noopener class=share-btn-linkedin><i class="fab fa-linkedin-in"></i></a></li><li><a href="whatsapp://send?text=Recursive%20n-dimensional%20scalar%20field%20interpolation%20https://rsouthern.github.io/post/scalarfield/" target=_blank rel=noopener class=share-btn-whatsapp><i class="fab fa-whatsapp"></i></a></li><li><a href="https://service.weibo.com/share/share.php?url=https://rsouthern.github.io/post/scalarfield/&title=Recursive%20n-dimensional%20scalar%20field%20interpolation" target=_blank rel=noopener class=share-btn-weibo><i class="fab fa-weibo"></i></a></li></ul></div><div class="media author-card content-widget-hr"><a href=https://rsouthern.github.io/><img class="avatar mr-3 avatar-circle" src=../../author/richard-southern/avatar_hu8b4b6ae9a405f1b6aee3b6ae457da189_173063_270x270_fill_q90_lanczos_center.jpg alt="Richard Southern"></a><div class=media-body><h5 class=card-title><a href=https://rsouthern.github.io/>Richard Southern</a></h5><h6 class=card-subtitle>Lead Developer, Katana</h6><p class=card-text>Leader, Graphics Researcher, Software Engineer</p><ul class=network-icon aria-hidden=true><li><a href=https://github.com/rsouthern target=_blank rel=noopener><i class="fab fa-github"></i></a></li><li><a href=https://www.linkedin.com/in/richard-southern-70289b12/ target=_blank rel=noopener><i class="fab fa-linkedin"></i></a></li><li><a href=../../Downloads/cv.pdf><i class="ai ai-cv"></i></a></li></ul></div></div><div class="article-widget content-widget-hr"><h3>Related</h3><ul><li><a href=../../post/mls/>n-Dimensional Moving Least Squares projection</a></li><li><a href=../../post/fdm/>The Force Density Method - A Brief Introduction</a></li><li><a href=../../publication/skinslide/>Fast simulation of skin sliding</a></li><li><a href=../../post/noisetexture/>A Templated Implementation of Noise Texture</a></li><li><a href=../../publication/cagebased/>Automatic cage construction for retargeted muscle fitting</a></li></ul></div></div></article><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/instant.page/5.1.0/instantpage.min.js integrity="sha512-1+qUtKoh9XZW7j+6LhRMAyOrgSQKenQ4mluTR+cvxXjP1Z54RxZuzstR/H9kgPXQsVB8IW7DMDFUJpzLjvhGSQ==" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/highlight.min.js integrity="sha512-TDKKr+IvoqZnPzc3l35hdjpHD0m+b2EC2SrLEgKDRWpxf2rFCxemkgvJ5kfU48ip+Y+m2XVKyOCD85ybtlZDmw==" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/r.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/c++.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.min.js integrity="sha512-SeiQaaDh73yrb56sTW/RgVdi/mMqNeM2oBwubFHagc5BkixSpP1fvqF47mKzPGWYSSy4RwbBunrJBQ4Co8fRWA==" crossorigin=anonymous></script><script>const code_highlighting=true;</script><script>const search_config={"indexURI":"/index.json","minLength":1,"threshold":0.3};const i18n={"no_results":"No results found","placeholder":"Search...","results":"results found"};const content_type={'post':"Posts",'project':"Projects",'publication':"Publications",'talk':"Talks",'slides':"Slides"};</script><script id=search-hit-fuse-template type=text/x-template>
      <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
      </div>
    </script><script src=https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin=anonymous></script><script src=../../js/wowchemy.min.4c2bca31150ce93c5a5e43b8a50f22fd.js></script><div class=container><footer class=site-footer><p class=powered-by></p><p class=powered-by>Published with
<a href=https://wowchemy.com target=_blank rel=noopener>Wowchemy</a> —
the free, <a href=https://github.com/wowchemy/wowchemy-hugo-modules target=_blank rel=noopener>open source</a> website builder that empowers creators.
<span class=float-right aria-hidden=true><a href=# class=back-to-top><span class=button_icon><i class="fas fa-chevron-up fa-2x"></i></span></a></span></p></footer></div><div id=modal class="modal fade" role=dialog><div class=modal-dialog><div class=modal-content><div class=modal-header><h5 class=modal-title>Cite</h5><button type=button class=close data-dismiss=modal aria-label=Close>
<span aria-hidden=true>&#215;</span></button></div><div class=modal-body><pre><code class="tex hljs"></code></pre></div><div class=modal-footer><a class="btn btn-outline-primary my-1 js-copy-cite" href=# target=_blank><i class="fas fa-copy"></i>Copy</a>
<a class="btn btn-outline-primary my-1 js-download-cite" href=# target=_blank><i class="fas fa-download"></i>Download</a><div id=modal-error></div></div></div></div></div></body></html>