<!doctype html><html lang=en-uk><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Wowchemy 4.8.0 for Hugo"><meta name=author content="Richard Southern"><meta name=description content="Generating consistent outline geometry on the geometry shader."><link rel=alternate hreflang=en-uk href=https://rsouthern.github.io/post/fins/><link rel=preconnect href=https://fonts.gstatic.com crossorigin><meta name=theme-color content="#2962ff"><script src=../../js/mathjax-config.js></script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css integrity="sha256-FMvZuGapsJLjouA6k7Eo2lusoAX9i0ShlWFG6qt7SLc=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/github.min.css crossorigin=anonymous title=hl-light><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/dracula.min.css crossorigin=anonymous title=hl-dark disabled><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.min.css integrity="sha512-1xoFisiGdy9nvho8EgXuXvnpR5GAMSjFwp40gSRE3NwdUdIMIKuPa7bqoUhLD0O/5tPNhteAsE5XyyMi5reQVA==" crossorigin=anonymous><script src=https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.2.2/lazysizes.min.js integrity="sha512-TmDwFLhg3UA4ZG0Eb4MIyT1O1Mb+Oww5kFG0uHqXsdbyZz9DcvYQhKpGgNkamAI6h2lGGZq2X8ftOJvF/XjTUg==" crossorigin=anonymous async></script><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js integrity crossorigin=anonymous async></script><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lora:400,400i%7CKarla:400,400i,700,700i%7CRoboto+Mono&display=swap"><link rel=stylesheet href=../../css/wowchemy.css><link rel=manifest href=../../index.webmanifest><link rel=icon type=image/png href=../../images/icon_hu0365f2187e15210a9118469a64220edc_142871_32x32_fill_lanczos_center_2.png><link rel=apple-touch-icon type=image/png href=../../images/icon_hu0365f2187e15210a9118469a64220edc_142871_192x192_fill_lanczos_center_2.png><link rel=canonical href=https://rsouthern.github.io/post/fins/><meta property="twitter:card" content="summary_large_image"><meta property="og:site_name" content="Richard's Blog"><meta property="og:url" content="https://rsouthern.github.io/post/fins/"><meta property="og:title" content="Realtime Silhouette Rendering with Consistent Geometric Fins | Richard's Blog"><meta property="og:description" content="Generating consistent outline geometry on the geometry shader."><meta property="og:image" content="https://rsouthern.github.io/post/fins/featured.png"><meta property="twitter:image" content="https://rsouthern.github.io/post/fins/featured.png"><meta property="og:locale" content="en-uk"><meta property="article:published_time" content="2018-05-01T00:00:00+00:00"><meta property="article:modified_time" content="2018-05-01T00:00:00+00:00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://rsouthern.github.io/post/fins/"},"headline":"Realtime Silhouette Rendering with Consistent Geometric Fins","image":["https://rsouthern.github.io/post/fins/featured.png"],"datePublished":"2018-05-01T00:00:00Z","dateModified":"2018-05-01T00:00:00Z","author":{"@type":"Person","name":"Richard Southern"},"publisher":{"@type":"Organization","name":"Richard's Blog","logo":{"@type":"ImageObject","url":"https://rsouthern.github.io/images/icon_hu0365f2187e15210a9118469a64220edc_142871_192x192_fill_lanczos_center_2.png"}},"description":"Generating consistent outline geometry on the geometry shader."}</script><title>Realtime Silhouette Rendering with Consistent Geometric Fins | Richard's Blog</title></head><body id=top data-spy=scroll data-offset=70 data-target=#TableOfContents><script>window.wcDarkLightEnabled=true;</script><script>const isSiteThemeDark=false;</script><script src=../../js/load-theme.js></script><aside class=search-results id=search><div class=container><section class=search-header><div class="row no-gutters justify-content-between mb-3"><div class=col-6><h1>Search</h1></div><div class="col-6 col-search-close"><a class=js-search href=#><i class="fas fa-times-circle text-muted" aria-hidden=true></i></a></div></div><div id=search-box><input name=q id=search-query placeholder=Search... autocapitalize=off autocomplete=off autocorrect=off spellcheck=false type=search class=form-control></div></section><section class=section-search-results><div id=search-hits></div></section></div></aside><nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id=navbar-main><div class=container><div class="d-none d-lg-inline-flex"><a class=navbar-brand href=../../>Richard's Blog</a></div><button type=button class=navbar-toggler data-toggle=collapse data-target=#navbar-content aria-controls=navbar aria-expanded=false aria-label="Toggle navigation">
<span><i class="fas fa-bars"></i></span></button><div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none"><a class=navbar-brand href=../../>Richard's Blog</a></div><div class="navbar-collapse main-menu-item collapse justify-content-start" id=navbar-content><ul class="navbar-nav d-md-inline-flex"><li class=nav-item><a class=nav-link href=../../#about><span>Home</span></a></li><li class=nav-item><a class=nav-link href=../../#publications><span>Publications</span></a></li><li class=nav-item><a class=nav-link href=../../#posts><span>Posts</span></a></li><li class=nav-item><a class=nav-link href=../../#talks><span>Talks</span></a></li></ul></div><ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2"><li class=nav-item><a class="nav-link js-search" href=# aria-label=Search><i class="fas fa-search" aria-hidden=true></i></a></li><li class="nav-item dropdown theme-dropdown"><a href=# class=nav-link data-toggle=dropdown aria-haspopup=true><i class="fas fa-moon" aria-hidden=true></i></a><div class=dropdown-menu><a href=# class="dropdown-item js-set-theme-light"><span>Light</span></a>
<a href=# class="dropdown-item js-set-theme-dark"><span>Dark</span></a>
<a href=# class="dropdown-item js-set-theme-auto"><span>Automatic</span></a></div></li></ul></div></nav><article class=article><div class="article-container pt-3"><h1>Realtime Silhouette Rendering with Consistent Geometric Fins</h1><div class=article-metadata><span class=article-date>May 1, 2018</span>
<span class=middot-divider></span><span class=article-reading-time>7 min read</span></div></div><div class="article-header article-container featured-image-wrapper mt-4 mb-4" style=max-width:500px;max-height:500px><div style=position:relative><img src=../../post/fins/featured.png alt class=featured-image></div></div><div class=article-container><div class=article-style><h3 id=background>Background</h3><p><a href=https://en.wikipedia.org/wiki/Cel_shading>Cel shading</a> is a common shading technique designed to make 3D geometry look like it was hand painted in a traditional way. While it is fairly trivial to darken vertices on the silhouette, to truly emulate the effect of a hand drawn outline, the ink outline must extend <em>outside</em> the silhouette of the object at a constant thickness for it to appear plausible. Games like <a href=https://en.wikipedia.org/wiki/Borderlands_(video_game)>Borderlands</a> make liberal use of outline geometry to enhance the non-photorealistic style of the game.</p><p>My starting point was the <a href="http://prideout.net/blog/?p=54">blog post</a> by Philip Rideout in which gaps between fins are blended using a blurring pass, which seemed wasteful, and may prohibit procedural outline effects like glowing or outline particles.</p><p>I started from scratch, but what I ended up with is a method similar to <a href=http://cgstarad.com/Docs/GSContours.pdf>Single Pass GPU Stylized Edges</a> by Hermosilla and Vazquez, although implemented on the geometry shader, and also requiring about half the additional geometry. I would also argue that the method I&rsquo;ve produced here is considerably simpler than any previous method.</p><h4 id=what-is-the-silhouette>What is the Silhouette?</h4><p>This is probably a good place to start. Assume for the moment that we have some nice continuous object (not a triangle mesh) like a perfect sphere. The silhouette is effectively a connected curve around the object where the surface of the object is exactly orthogonal to the direction of the viewer. Consider the horizon - the silhouette is the exact point at which the ground meets the sky.</p><p>Based on this we could formulate a simple definition of the silhouette as the set of all points \(x\) for which \(\mathbf{v}_x \cdot \mathbf{n}_x = 0 \), where \(\mathbf{v}_x\) is the view vector from the eye to \(x\) and \(\mathbf{n}_x\) is the normal at the point \(x\).</p><h3 id=method-overview>Method Overview</h3><h4 id=determining-the-silhouette-of-a-triangle-mesh>Determining the silhouette of a triangle mesh</h4><p>Now lets consider this on a triangle mesh. Any silhouette is only going exist between points on two edges of a subset of triangles on the mesh. We will assume that our triangle mesh is sufficiently dense so we can approximate the silhouette across the triangle face with a straight line (it would be possible to generate smoother curves using a Bezier spline or equivalent). The comparison of the discrete and the continuous silhouette case is demonstrated in the figure below:</p><center><img src=continuous_silhouette.svg></center><p>Remember that a triangle mesh is typically an approximation of some smoother surface representation, and should in most cases have vertex normals defined which effectively allow us to generate smooth shading across each face, giving the illusion of a continuous surface representation. We can use this knowledge to determine which faces are on the silhouette.</p><p>Consider an edge with vertices at \(p_{0,1} \) with vertex normals \( \mathbf{n}_{0,1} \) respectively. If \(\mathbf{v}_0 \cdot \mathbf{n}_0 &lt; 0 \) and \(\mathbf{v}_1 \cdot \mathbf{n}_1 > 0 \) (or visa versa), then somewhere along this edge there is an \(x\) for which \(\mathbf{v}_x \cdot \mathbf{n}_x = 0 \).</p><p>A wary reader will note that \(\mathbf{v}_0 \neq \mathbf{v}_1\) which might cause problems, but as we will see, all view vectors \(\mathbf{v}_x\) will be the same \(\forall x\).</p><h4 id=interpolation>Interpolation</h4><p>So we need to find the point \(x\) across the edge for which \(\mathbf{v}_x \cdot \mathbf{n}_x = 0 \). We&rsquo;re going to make a couple of assumptions to simplify things. The first assumption is that we&rsquo;re going to use simple linear interpolation for performance reasons. Accuracy will be affected, but we&rsquo;re going to assume that the input mesh is dense and any accuracy issues will not be noticeable.</p><p>Linear interpolation would imply that we&rsquo;re looking for some \(t\) for which \((1-t)\mathbf{v}_0 \cdot \mathbf{n}_0 + t \mathbf{v}_1 \cdot \mathbf{n}_1 = \mathbf{v}_x \cdot \mathbf{n}_x = 0 \), e.g. the interpolation parameter for which the the normal is zero.</p><p>The second assumption we&rsquo;ll be creating the geometry of the fin on the <a href=https://www.khronos.org/opengl/wiki/Geometry_Shader>geometry shader</a>, which means that by <a href=https://www.khronos.org/opengl/wiki/Vertex_Shader>convention</a> we can rely on the fact that the geometry has already been projected, which means it already lives within a <a href=https://cglearn.codelight.eu/pub/computer-graphics/frames-of-reference-and-projection>canonical viewing volume</a>. We can now reliably state that \(\mathbf{v}_0 = \mathbf{v}_1 = [0,0,-1]^T\), i.e. the view vector for all vertices is just from the origin looking in the \(-z\) direction by the <a href=http://www.songho.ca/opengl/gl_transform.html>OpenGL camera convention</a>.</p><p>So this means that we can simplify the formulation significantly to just \( (1-t) \mathbf{n}_{(0,z)} + t\mathbf{n}_{(1,z)} = 0 \), which yields \( t = -\mathbf{n}_{(0,z)} / (\mathbf{n}_{(1,z)}-\mathbf{n}_{(0,z)}) \). Built into this formula is also the implicit test: \( 0 \leq t \leq 1 \implies \) the edge crosses the silhouette.</p><p>Below is this trivial function as implemented in the geometry shader:</p><pre><code class=language-cpp>/** This is where most of the magic happens - it determines the interpolation value 
  * based on the z values of the two normals in order to detemrine a normal pointing 
  * out orthogonal to the view direction.
  * \param n0,n1 The two input normals
  * \return The output interpolation value (between 0 and 1 if edge is on the silhouette)  
  */
float isSilhouette(in vec3 n0, in vec3 n1) {
    // Trivial case: the normals are the same, so we'll just pick a point in the middle
    if (n1.z == n0.z) {
        return 0.5;
    } else {
        // Use our formula to determine the interpolation value and return a boolean based
        // on whether the interpolant is within the two input vectors
        return - n0.z / (n1.z - n0.z);        
    }
}
</code></pre><h4 id=putting-it-together>Putting it together</h4><p>The geometry shader to generate fins accepts a triangle as input and spawns a triangle strip of 4 vertices as output. Each triangle is going to be processed, and we can expect neighbouring triangles on the silhouette to be consistent - see the image below for an example (I appreciate that it&rsquo;s not great):</p><center><img src=discrete_silhouette.svg></center><p>The geometry shader iterates over all edges of the triangle and determines the value of \(t\) to see if it lies on the silhouette. If it does, a fin vertex and normal is determined using a straight linear interpolation (via the built-in mix function):</p><pre><code class=language-cpp>    // Iterate over all the edges in our triangle
    int j;
    for (int i = 0; i &lt; 3; ++i) {
        j = (i+1)%3;
        t[cnt] = isSilhouette(normal[i], normal[j]);
        if ((t[cnt] &gt;= 0.0) &amp;&amp; (t[cnt] &lt;= 1.0)) {
            finVerts[cnt] = mix(pos[i], pos[j], t[cnt]);
            finNorms[cnt] = normalize(mix(normal[i], normal[j], t[cnt]));
            ++cnt;
        }
    }
</code></pre><p>I did also experiment with higher order mixing methods, but these showed no discernable improvement and just added significantly to the computation cost and complexity so these approaches were scrapped.</p><p>Now if the variable cnt is exactly 2 then we know that this triangle cuts the silhouette and we need to generate a triangle strip fin:</p><pre><code class=language-cpp>    // If count is less than 2 don't do anything as there isn't a fin
    if (cnt &gt;= 2) {
        // Create our triangle strip from the two input vertices and normals        
        finColour = vec4(0,0,0,1); // You might want to visualise something with the color
        gl_Position = vec4(finVerts[0],1.0);
        EmitVertex();
        gl_Position = vec4(finVerts[1],1.0);
        EmitVertex();
        gl_Position = vec4(finVerts[0] + finScale * finNorms[0],1.0);
        EmitVertex();
        gl_Position = vec4(finVerts[1] + finScale * finNorms[1],1.0);
        EmitVertex();

        EndPrimitive();
    }
</code></pre><p>Note that the rendering of the fin is an additional render pass performed after you&rsquo;ve rendered the main geometry, as the geometry shader will effectively &ldquo;eat&rdquo; the original geometry.</p><h3 id=results>Results</h3><p>Here are a couple of Buddha&rsquo;s of various levels of thickness:</p><table width=100%><tr><td><img src=buddha1.png width=100%></td><td><img src=buddha2.png width=100%/></td><td><img src=buddha3.png width=100%/></td></tr></table><p>The results are close to perfect: the fins are consistent about both internal and external silhouettes. There are still a couple of problems which need resolving:</p><ul><li>The normals are not transformed correctly after projection. This is because the normals are needed in the world coordinates for the lighting calculations. You can see the error in that the line is not the same width everywhere on the silhouette. Unfortunately I&rsquo;ve not yet figured out the correct method to transform the normals to be correct according to the canonical viewing volume - feel free to contact me if you have a solution to this.</li><li>The lines don&rsquo;t taper when nearing the edge of an internal silhouette (leading to &ldquo;sharpy edges&rdquo;). This could be fixed by tiling a round texture map on the silhouette so the borders become rounded.</li><li>I have not explored all the fun effects that fins can do, like glow or illustrative visualisation: this is up to you!</li></ul><h3 id=downloads>Downloads</h3><p>The source code is hosted on <a href=https://github.com/rsouthern/Examples>GitHub</a>. Clone it from the repository using the following command from your console:</p><pre><code class=language-shell>git clone https://github.com/rsouthern/Examples
</code></pre><p>This example is under rendering/fins.</p></div><div class=article-tags><a class="badge badge-light" href=../../tag/opengl/>opengl</a>
<a class="badge badge-light" href=../../tag/rendering/>rendering</a>
<a class="badge badge-light" href=../../tag/shaders/>shaders</a></div><div class=share-box aria-hidden=true><ul class=share><li><a href="https://twitter.com/intent/tweet?url=https://rsouthern.github.io/post/fins/&text=Realtime%20Silhouette%20Rendering%20with%20Consistent%20Geometric%20Fins" target=_blank rel=noopener class=share-btn-twitter><i class="fab fa-twitter"></i></a></li><li><a href="https://www.facebook.com/sharer.php?u=https://rsouthern.github.io/post/fins/&t=Realtime%20Silhouette%20Rendering%20with%20Consistent%20Geometric%20Fins" target=_blank rel=noopener class=share-btn-facebook><i class="fab fa-facebook"></i></a></li><li><a href="mailto:?subject=Realtime%20Silhouette%20Rendering%20with%20Consistent%20Geometric%20Fins&body=https://rsouthern.github.io/post/fins/" target=_blank rel=noopener class=share-btn-email><i class="fas fa-envelope"></i></a></li><li><a href="https://www.linkedin.com/shareArticle?url=https://rsouthern.github.io/post/fins/&title=Realtime%20Silhouette%20Rendering%20with%20Consistent%20Geometric%20Fins" target=_blank rel=noopener class=share-btn-linkedin><i class="fab fa-linkedin-in"></i></a></li><li><a href="whatsapp://send?text=Realtime%20Silhouette%20Rendering%20with%20Consistent%20Geometric%20Fins%20https://rsouthern.github.io/post/fins/" target=_blank rel=noopener class=share-btn-whatsapp><i class="fab fa-whatsapp"></i></a></li><li><a href="https://service.weibo.com/share/share.php?url=https://rsouthern.github.io/post/fins/&title=Realtime%20Silhouette%20Rendering%20with%20Consistent%20Geometric%20Fins" target=_blank rel=noopener class=share-btn-weibo><i class="fab fa-weibo"></i></a></li></ul></div><div class="media author-card content-widget-hr"><a href=https://rsouthern.github.io/><img class="avatar mr-3 avatar-circle" src=../../author/richard-southern/avatar_hu8b4b6ae9a405f1b6aee3b6ae457da189_173063_270x270_fill_q90_lanczos_center.jpg alt="Richard Southern"></a><div class=media-body><h5 class=card-title><a href=https://rsouthern.github.io/>Richard Southern</a></h5><h6 class=card-subtitle>Lead Developer, Katana</h6><p class=card-text>Leader, Graphics Researcher, Software Engineer</p><ul class=network-icon aria-hidden=true><li><a href=https://github.com/rsouthern target=_blank rel=noopener><i class="fab fa-github"></i></a></li><li><a href=https://www.linkedin.com/in/richard-southern-70289b12/ target=_blank rel=noopener><i class="fab fa-linkedin"></i></a></li><li><a href=../../Downloads/cv.pdf><i class="ai ai-cv"></i></a></li></ul></div></div><div class="article-widget content-widget-hr"><h3>Related</h3><ul><li><a href=../../post/noisetexture/>A Templated Implementation of Noise Texture</a></li><li><a href=../../post/curv/>Principal Curvature Aligned Anisotropic Shading</a></li><li><a href=../../publication/geomorph/>Creation and control of real-time continuous level of detail on programmable graphics hardware</a></li></ul></div></div></article><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/instant.page/5.1.0/instantpage.min.js integrity="sha512-1+qUtKoh9XZW7j+6LhRMAyOrgSQKenQ4mluTR+cvxXjP1Z54RxZuzstR/H9kgPXQsVB8IW7DMDFUJpzLjvhGSQ==" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/highlight.min.js integrity="sha512-TDKKr+IvoqZnPzc3l35hdjpHD0m+b2EC2SrLEgKDRWpxf2rFCxemkgvJ5kfU48ip+Y+m2XVKyOCD85ybtlZDmw==" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/r.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/c++.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.min.js integrity="sha512-SeiQaaDh73yrb56sTW/RgVdi/mMqNeM2oBwubFHagc5BkixSpP1fvqF47mKzPGWYSSy4RwbBunrJBQ4Co8fRWA==" crossorigin=anonymous></script><script>const code_highlighting=true;</script><script>const search_config={"indexURI":"/index.json","minLength":1,"threshold":0.3};const i18n={"no_results":"No results found","placeholder":"Search...","results":"results found"};const content_type={'post':"Posts",'project':"Projects",'publication':"Publications",'talk':"Talks",'slides':"Slides"};</script><script id=search-hit-fuse-template type=text/x-template>
      <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
      </div>
    </script><script src=https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin=anonymous></script><script src=../../js/wowchemy.min.4c2bca31150ce93c5a5e43b8a50f22fd.js></script><div class=container><footer class=site-footer><p class=powered-by></p><p class=powered-by>Published with
<a href=https://wowchemy.com target=_blank rel=noopener>Wowchemy</a> —
the free, <a href=https://github.com/wowchemy/wowchemy-hugo-modules target=_blank rel=noopener>open source</a> website builder that empowers creators.
<span class=float-right aria-hidden=true><a href=# class=back-to-top><span class=button_icon><i class="fas fa-chevron-up fa-2x"></i></span></a></span></p></footer></div><div id=modal class="modal fade" role=dialog><div class=modal-dialog><div class=modal-content><div class=modal-header><h5 class=modal-title>Cite</h5><button type=button class=close data-dismiss=modal aria-label=Close>
<span aria-hidden=true>&#215;</span></button></div><div class=modal-body><pre><code class="tex hljs"></code></pre></div><div class=modal-footer><a class="btn btn-outline-primary my-1 js-copy-cite" href=# target=_blank><i class="fas fa-copy"></i>Copy</a>
<a class="btn btn-outline-primary my-1 js-download-cite" href=# target=_blank><i class="fas fa-download"></i>Download</a><div id=modal-error></div></div></div></div></div></body></html>